[TOC]
## 1. jdk/jre/jvm的关系

### jvm
* 全称 java virtual machine，java虚拟机，java程序运行的基础，本质是一套规范，规定了虚拟机内存的管理方式，class文件的格式等。具体的虚拟机是由不同厂商实现的，比如Hotspot。
* 是java语言平台无关性的基石，通过jvm隔绝了操作系统的区别。
* 本质上，jvm执行的是class文件，只要符合jvm规范的class文件都可以被执行，因此其他语言比如ruby编译后得到的class文件也可以运行在java虚拟机上。jvm可以做到平台无关，甚至编程语言无关。

### jre
全称 java runtime environment，是支持java程序运行的标准环境。包含了jvm和java SE API。

### jdk
全称java development kit，是支持Java程序开发的最小环境。包括了jre和jvm。

## 2. 虚拟机运行探究

java程序的运行，其实就是创建一个个对象，然后执行对象里面的方法的过程。那么对象是如何创建，方法是如何执行的呢？现在假设我要创建一个叫做mj的虚拟机，需要怎么做呢？

### mj虚拟机问世
#### new一个对象
我们都知道，创建一个对象最简单的方式就是new一个，那么new一个对象的时候，到底干了些啥呢，下面让我们大胆的猜测一下。
现在有个User对象如下，有name和age属性，还有对应的getName等方法。现在我们执行new User()，会发生什么呢。

假设需要创建一个对象，首先得知道这个对象是什么样的吧，类名是什么，实现了什么接口，有什么静态变量，什么属性，哪些方法等等。也就是说我总得先知道这个类的结构吧。所以我肯定要先把这个类的结构解析一下。好，那现在需要创建的对象有什么结构知道了，那我就在内存里面分配一个空间，记录下属性、变量、方法等等，那这个对象就创建好了。

#### 方法的执行
好，现在对象在内存里面也有了，我们有了对象，就可以执行他的方法，程序运行不就是一个方法调用另一个方法么。那这个过程我们的虚拟机要怎么实现呢？

我们看看方法调用的过程，A调用B，B调用C，C执行完，返回，然后B执行完，返回，然后A执行完，返回。先执行的方法后结束，这个像什么结构？对，像栈，先进后出。好，那我从第一个方法执行的时候就给它一个栈，调用一个方法就在栈里面记一下方法的信息，执行完了把这个方法的信息出栈，这样的话这个栈不就是方法调用到结束的过程了嘛。但是，我怎么判断是第一个方法执行呢？我们java程序的执行不是以线程为单位的么，想要开始执行方法，肯定在线程里面吧，那好，那我们就给每个java线程都分配一个栈，用来记录它方法的调度和执行。

#### 问题和优化
很好，现在mj虚拟机第一版已经大致出炉了，运行逻辑如下

嗯，看着好像可以运行。然后就拿着这个虚拟机跑了起来。
因为我们的计算机cpu运行的时候是个每个线程分配时间片的，每个线程跑一会儿可能就切到另一个线程了，我们的虚拟机一运行就不行了，因为一旦切换线程然后切换回来丢丢失了运行的信息了，简单讲，就是不知道自己执行到哪一行代码了。不过这个好办，我们在一个地方记录每次执行的地址不就得了么。运行逻辑这就调整了一下，如下:

好，现在切换线程也不怕了。虚拟机起码跑了起来。
跑了一会儿，我们发现这个性能不咋地啊，没关系，看看虚拟机都在干些啥。不看不知道，一看吓一跳，怎么一个个线程都在解析类的结构啊？奥，因为我们每一次new一个对象都要解析一次。这个好像可以优化，因为类的结构不是不变的么，我们把类静态的结构拿出来，这样只要第一次创建对象的时候解析一下就好了额。运行逻辑又优化了一下，如下:

很好，现在这个mj虚拟机已经可以跑起来了，每个类被解析之后存起来，下次new对象时就不用重复解析了；通过每个线程都有的一个栈，记录了线程里面方法的调度与执行；用了一块内存，不断的记录程序当前执行的行号，线程切换也没关系了。

然后这个mj虚拟机问世了，卖了很多钱。

### mj虚拟机总结
虽然不存在这个mj虚拟机，但是这个mj虚拟机一定程度上是可以反映java虚拟机的运行机制的。  

* 每个类解析的过程，被称为类加载；
* 解析之后会把类静态结构存储起来，存储的地方叫做方法区；
* 每个线程都有的那个栈，被称为java虚拟机栈，每次方法调用的时候都会把方法的信息记录到一个叫做栈帧的东西里面，然后入栈。
* 因为可能会执行一些操作系统的方法，比如C++库的方法，所以还有一个本地方法栈，类似虚拟机栈；
* 那个我们用来记录程序当前执行的行号的，叫做程序计数器；
* 我们用来生成对象的地方，叫做堆。

## 3. 运行时数据区域
java虚拟机的运行机制远比mj虚拟机要复杂，先来看看其运行时数据划分的区域，了解一下有哪些区域以及各个区域的作用。

### 程序计数器
显然是线程私有的，如果线程正在执行的是一个Java方法，那这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。
他所占用的空间很小，但是根据虚拟机规范的描述，他的空间一定要能容纳方法或者native的返回地址。个人觉得64位就够了。
因为占用空间很小，而且绝对足够，这里是java虚拟机中唯一规定的不会发生内存溢出的地方。

### java虚拟机栈
记录的是每个线程中方法的调度信息，显然也是线程私有的。由栈帧组成，每个栈帧保存了局部变量表、操作数栈、动态链接、方法出口等信息。
既然是栈，那么栈的深度肯定是有个上限的，因此该区域是可能会发生内存溢出的。发生的情况有三中。
+ 1. 方法嵌套调用太多，甚至无限的递归，导致栈满了，会抛出StackOverflowError。
+ 2. 每个方法内部的局部变量太多，导致每个栈帧很大，同时方法调用又不少，导致栈满了，会抛出StackOverflowError。
+ 3. 开启了无数个线程，不足以给新的线程分配栈了，会抛出 OutOfMemoryError，这种情况比较少出现。

### 本地方法栈
和java虚拟机类似，不过他作用的是native方法。

## 3. 对象的生命周期

## 4. 溢出异常